
extends c

# We want to overwrite everything in parent ft.
priority 0
###########################################################################
#			    Global functions 						  #
###########################################################################

global !p

def write_docstring_args(arglist, snip):
	args = str(arglist).split(',')

	if len(args) > 1:
		c = 0
		for arg in args:
			if c == 0:
				snip.rv += arg
				c = 1
			else:
				snip += '*       : %s' % arg.strip()
	else:
		snip.rv = args[0]


endglobal
#<------------^^^^^^^^^^^^^^^^^-_____________________>
#<----------NO idead what is this--------------------->

#available snips
snippet SNIPS
//yes
//no
//in
//va
//rng
//mint
//index_compress
//generator
//PNC
//sieve
endsnippet

#long long
snippet LL
using i64 = long long;
endsnippet
#index compression
snippet index_compress
void compress( vector<int> &a){
      int n = a.size();
      vector<int> d = a;
      sort( d.begin(), d.end() );
      d.resize( unique( d.begin(), d.end()) - d.begin());
      for( int i = 0; i < n; i++){
            a[i] = lower_bound( d.begin(), d.end(), a[i]) - d.begin();
      }
}
endsnippet

snippet yes
cout << "Yes\n";
endsnippet

snippet YES
cout << "YES\n";
endsnippet

snippet no
cout << "No\n";
endsnippet

snippet NO
cout << "NO\n";
endsnippet

snippet in
int n; cin >> n;
$0
endsnippet

snippet va
vector<int> a(n);
$0
endsnippet

snippet ai
rep(i,n) cin >> a[i];
$0
endsnippet

#debug header
snippet debug

#ifdef LOCAL
#include "debug.cpp"
#else
#define debug(...) 42
#endif

endsnippet


#data types start ------------------------>
snippet vb
vector<bool> $0
endsnippet

snippet vi
vector<int> $0
endsnippet

snippet pi
pair<int,int> $0
endsnippet

snippet vl
vector<i64> $0
endsnippet

snippet vvi
vector<vector<int>> $0
endsnippet

snippet vvl
vector<vector<i64>> $0
endsnippet

snippet vvb
vector<vector<bool>> $0
endsnippet

#data types end ------------------------>

#print run time
snippet time
cerr << "Time : " << 1000 * ((double)clock()) / (double)CLOCKS_PER_SEC << "ms ";
endsnippet

#random number generator
snippet rng
mt19937_64 RNG(chrono::steady_clock::now().time_since_epoch().count());
endsnippet
#template with test cases
snippet solve
#include<bits/stdc++.h>

using namespace std;
#define rep(i,b) for( int i = 0; i < (b); ++i)

void solve(){
	$0
}

int32_t main()
{ 
      ios_base::sync_with_stdio(false);
      cin.tie(0);
	int tc; cin >> tc;
	while(tc--) solve();
}

endsnippet

#template without test cases
snippet main
#include<bits/stdc++.h>

using namespace std;
#define rep(i,b) for( int i = 0; i < (b); ++i)

int32_t main()
{ 
      ios_base::sync_with_stdio(false);
      cin.tie(0);
	
	$0
}

endsnippet
#MOD INT
snippet mint
typedef struct mint{
      int x;
      mint(){
            x = 0;
      }
      mint(int b){
            x = b;
            if( x < 0) x += mod;
      }
      mint(long long b){
            x = b;
            if( x < 0) x += mod;
      }
      mint(const mint& b){
            x = b.x;
      }
      mint& operator=(const int& b){
            x = b;
            x = x%mod;
            return *this;
      }
      mint& operator=(const mint& b){
            if(this == &b)
                  return *this;
            x = b.x;
            return *this;
      }
      mint& operator++(){
            x++;
            if( x == mod) x = 0;
            return *this;
      }
      mint operator++(int){
            mint old = *this;
            x++;
            if( x == mod) x = 0;
            return old;
      }
      mint& operator--(){
            if( x == 0) x = mod;
            x--;
            return *this;
      }
      mint operator--(int){
            mint old = *this;
            if( x == 0) x = mod;
            x--;
            return old;
      }
      mint& operator+=(const mint& b){
           x += b.x;
           if( x >= mod) x -= mod;
           return *this;
      }
      mint& operator-=(const mint& b){
            x -= b.x;
            if( x < 0) x += mod;
            return *this;
      }
      mint& operator*=(const mint& b){
            long long z = (long long)x*b.x;
            x = z%mod;
            return *this;
      } 
       mint pow(int p)const{
             mint t = *this, r = 1;
             while(p){
                   if(p &1){
                         r *= t;
                   }
                   t *= t;
                   p >>= 1;
             }
             return r;
      }

      mint inverse()const{
            return pow(mod-2);
      }
      mint& operator/=(const mint& b){
            return *this = *this * b.inverse();
      }
      mint operator+()const{
            return *this;
      }
      mint operator-()const{
            return mint() - *this;
      }
      friend mint operator+(const mint& a, const mint& b) { return mint(a) += b; }
      friend mint operator-(const mint& a, const mint& b) { return mint(a) -= b; }
      friend mint operator*(const mint& a, const mint& b) { return mint(a) *= b; }
      friend mint operator/(const mint& a, const mint& b) { return mint(a) /= b; }
      friend bool operator==(const mint& a, const mint& b){ return a.x == b.x; };
      friend bool operator!=(const mint& a, const mint& b){ return a.x != b.x; };

     friend std::ostream& operator<<(std::ostream& os,const mint& a){
            return os << a.x;
      }
     explicit operator bool() const {
        return x != 0;
     }
} Z;

endsnippet

snippet generator

#include<bits/stdc++.h>

using namespace std;
//DEBUG
using i64 = long long;
#define rep(i,b) for( int i = 0; i < (b); ++i)


int32_t main(int argc, char* argv[])
{ 
      ios_base::sync_with_stdio(false);
      cin.tie(0);
      
      mt19937_64 RNG( atoi(argv[1]));
      // start code here
	$0
}
endsnippet

snippet PNC

class PNC{
      public:
      static long long mod;
      static long long n;
      static vector<long long> factorial;

      static void init(){
            factorial.assign(n+1,0);
            factorial[0] = factorial[1] = 1;
            for( long long i = 2; i <= n; i++){
                  factorial[i] = ( factorial[i-1]*i) % mod;
            }
      }
      static long long pow( long long a, long long b){
            long long c = 1;
            while( b > 1){
                  if( b&1 ){
                        c = (c * a) % mod;
                        b--;
                  }
                  a = (a*a) % mod;
                  b /= 2;
            }
            return (c*a)%mod;
      }
     static long long inverse(long long a){
           return pow(a, mod-2);
     }
      static long long fact(long long a){
           return factorial[a];
     }
     static long long nck(long long n, long long k){
           if( k < 0 or k > n) return 0LL;
           long long res = factorial[n];
           long long den = ( factorial[k] * factorial[n-k]) % mod;
           return ( res * inverse(den)) % mod;
     }
     static long long npk(long long n, long long k){
           if( k < 0 or k > n) return 0LL;
           long long res = factorial[n];
           long long den = factorial[n-k];
           return ( res * inverse(den)) % mod;
     }
};
vector<long long> PNC::factorial;
long long PNC::mod = 1e9+7;$0
long long PNC::n = 2e5+1;
endsnippet

snippet sieve
struct sieve{
      vector<int> a;
      int n;
      sieve(){
            n = 2e5+10; 
            a.assign(n,0);
            fill();
      }
      sieve(int _n){
            n = _n;
            a.assign(n,0);
            fill();
      }
      void fill(){
            a[0] = a[1] = -1;
            for( int i = 2; i < n; i++){
                  if( a[i] != 0) continue;
                  for( int j = i; j < n; j += i){
                       a[j] = i; 
                  }
            }
      }
      bool isPrime(int x){
            return a[x] == x;
      }
};
endsnippet
snippet dsu
struct DSU{
     vector<int> a;
     void init(int n) { a = vector<int>(n,-1); }
     int get(int x){
           if( a[x] < 0) return x;
           else return a[x] = get(a[x]);
     }
     bool same(int x, int y) {return get(x) == get(y);}
     int size(int x){ return -a[get(x)]; };
     int join(int x, int y){
           x = get(x), y = get(y); if( x == y) return 0;
           if( a[x] > a[y]) swap(x,y);
           a[x] += a[y]; a[y] = x; return 1;
     }
};
endsnippet
# vim:ft=snippets:
